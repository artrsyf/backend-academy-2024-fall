- [Почему маскот Go - голубой суслик?](#почему-маскот-go---голубой-суслик)
- [Принцип работы errors.Is](#принцип-работы-errorsis)
- [Особенности конкурентности и многопоточности в golang](#особенности-конкурентности-и-многопоточности-в-golang)
- [Сборщик мусора](#сборщик-мусора)
- [Whitebox или blackbox тестирование?](#whitebox-или-blackbox-тестирование)
- [Когда объявлять зависимости интерфейсами?](#когда-объявлять-зависимости-интерфейсами)
- [Почему в Go нет классов и как это влияет на проектирование приложений?](#почему-в-go-нет-классов-и-как-это-влияет-на-проектирование-приложений)
- [bytes.Buffer](#bytesbuffer)
- [Горутины и замыкания](#горутины-и-замыкания)
- [Для каких задач используют golang](#для-каких-задач-используют-golang)
- [Third-party библиотеки и boilerplate](#third-party-библиотеки-и-boilerplate)
- [Уязвимости](#уязвимости)

# Ответы на различные вопросы

## Почему маскот Go - голубой суслик?

Развёрнутый ответ на этот вопрос есть в [этой статье](https://go.dev/blog/gopher). Короткий ответ: 
поменяли форму и перекрасили маскота какой-то радиостанции.

## Принцип работы `errors.Is`

> Как errors.Is() понимает, что ошибки одинаковые? Он сравнивает адреса?

Посмотрим на реализацию этой функции:

```go
func Is(err, target error) bool {
    if target == nil {
        return err == target // err == nil
    }

    isComparable := reflectlite.TypeOf(target).Comparable()
    for {
        if isComparable && err == target {
            return true
        }
		
        if x, ok := err.(interface{ Is(error) bool }); ok && x.Is(target) {
            return true
        }
		
        switch x := err.(type) {
        case interface{ Unwrap() error }:
            err = x.Unwrap()
            if err == nil {
                return false
            }
        case interface{ Unwrap() []error }:
            for _, err := range x.Unwrap() {
                if Is(err, target) {
                    return true
                }
            }
            return false
        default:
            return false
        }
    }
}
```

Используется комбинация нескольких подходов:

- сравнение значений, если это возможно (если target -- comparable)
- использование функции-ресивера `Is`, если `err` имеет такую функцию-ресивер
- рекурсивный вызов с "родительскими" ошибками, которые возвращает функция-ресивер `Unwrap` (2 варианта этой функции) 

Если ошибки оборачиваются с помощью конструкции вида `fmt.Errorf("this error is caused by %w", err)`, то у ошибки,
которую возвращает `fmt.Errorf()`, будет функция-ресивер `Unwrap() []error`, а в более старых версиях golang `Unwrap() error`.

## Особенности конкурентности и многопоточности в golang

> Чем конкурентность (многопоточность) в го отличается от других языков, 
> про оптимизации на уровне железа нам говорили вскользь, 
> хочется узнать про потокобезопасные структуры данных в го, 
> как часто на практике приходится писать конкурентный код, как отлавливать ошибки?

Ответы на этот вопрос будут на следующем семинаре, который будет целиком посвящён горутинам и синхронизации.

## Сборщик мусора

> Какие есть оптимизации GC (сборщика мусора), как он работает?

На одном из следующих семинаров будет рассказано о GC и о том, как он работает.

## Whitebox или blackbox тестирование?

> Как стоит балансировать между whitebox и blackbox тестированием? 
> Если в моем пакете большое количество приватных функций/методов, 
> то обработка ошибок на самом верхнем уровне при использовании 
> blackbox может быть не самой удобной.?

Blackbox всегда является предпочтительным подходом для тестирования. 

Использовать whitebox никогда не желательно.

Если большое количество приватных функций-ресиверов осложняет тестирование, то следует 
сделать их публичными. Нет ничего плохого в том, чтобы сделать все функции-ресиверы публичными.

## Когда объявлять зависимости интерфейсами?

> Как понять, когда стоит подменять сущность из domain ее интерфейсом в application?

Всегда предпочтительней строить зависимости от абстракций (интерфейсов), а не от конкретных типов-реализаций.
Об этом напрямую говорят принципы [SOLID](https://ru.wikipedia.org/wiki/SOLID_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)),
а именно, принцип инверсии зависимостей (dependency inversion principle).

Если писать код, зависящий от абстракции, то:
1. Его проще тестировать -- можно создать моки и эмулировать нужное поведение, вместо того, чтобы проводить сложную инициализацию конкретного типа.
2. Его проще поддерживать -- можно заменить одну конкретную реализацию на другую. К примеру, сначала получать данные из БД PostgreSQL, а потом заменить на получение данных из кэша Redis.

## Почему в Go нет классов и как это влияет на проектирование приложений?

Разработчики golang приняли осознанное решение отказаться от классов. В общепринятом подходе, от классов в ЯП
ожидают, что они соответствуют 3 принципам ООП: инкапсуляция, **наследование** и полимформизм. 

От классов отказались, чтобы не реализовывать наследование и не создавать тем самым сложные иерархии типов. 
В golang вместо этого используют композицию:

```go
type Base1 struct {
    ...
}

type Base2 struct {
    ...
}

type Derivative1 struct {
    Base1
    Base2
}
// или
type Derivative2 struct {
    B1 Base1
    B2 Base2
}
```

Что касается инкапсуляции и полиформизма, то golang их по-своему реализует: есть приватные функции и поля структур (инкапсуляция),
а зависимости принято объявлять интерфейсом, что позволяет использовать множество конкретных реализаций (полиморфизм).

Эти ограничения не очень сильно влияют на **проектирование** приложений, 
ведь основная задача проектирования -- состыковать друг с другом кубики (абстракции).

## bytes.Buffer

> Хотелось бы послушать про использование bytes.Buffer. 
> Стоит ли его всегда предпочитать над []byte или просто 
> стоит отталкиваться от интерфейса, с которым работаешь?

Фактически, `bytes.Buffer` -- это просто обвязка над `[]byte`:
```go
type Buffer struct {
    buf      []byte // contents are the bytes buf[off : len(buf)]
    off      int    // read at &buf[off], write at &buf[len(buf)]
    lastRead readOp // last read operation, so that Unread* can work correctly.
}
```

Эти 2 типа могут быть преобразованы друг в друга:
```go
// []byte -> *bytes.Buffer
func NewBuffer(buf []byte) *Buffer { return &Buffer{buf: buf} }

// *bytes.Buffer -> []byte
func (b *Buffer) Bytes() []byte { return b.buf[b.off:] }
```

`bytes.Buffer` содержит ряд функций-ресиверов, которые делают возможным использование
нижележащего слайса байт в качестве разных стандартных абстракций, вроде `io.Reader`.

За исключением случаев, когда нужно выполнять низкоуровневую работу со слайсом, следует использовать `bytes.Buffer`.

## Горутины и замыкания

> Возник вопрос насчет замыканий и горутин при просмотре этого видео (https://youtu.be/Qf24zMzMmgI?t=683). 
> Правильно ли я понимаю, что функции и горутины при замыкании (или при доступе к переменным из глобального скоупа) 
> берут значения по ссылке ? в данном на видео примере, примитив синхронизации sync.WaitGroup{} передается по ссылке 
> и все операции wg.Done() выполняются над исходной переменной. Тоже самое происходит и с переменной i. 
> Однако до версии go 1.22.0 переменная i создавалась 1 раз перед циклом, именно поэтому возникал баг с тем, 
> что все горутины (или обычные функции) работали с одной и той же переменной? 
> Правильно ли я все понимаю, или здесь проблема в чем-то другом? Спасибо!

Пример из видео:
```go
package main

import (
    "fmt"
    "sync"
)

func main() {
    wg := sync.WaitGroup{}

    wg.Add(5)
    for i := 0; i < 5; i++ {
        go func() {
            defer wg.Done()
            fmt.Println(i)
        }()
    }

    wg.Wait()
}
```

Результат для версии go 1.23.0:
```
2
4
1
0
3
```

Результат для версии go 1.21.10:
```
4
5
5
5
5
```

(вывод может отличаться, например, все числа в выводе могут быть пятёрками)

Значение i в анонимной горутине берётся из замыкания. Замыкание можно представить как структуру (она строится во время компиляции):
```go
type closure_data struct {
    FuncPtr uintptr
    int *i
}
```

В документации go [указано](https://go.dev/ref/spec#Function_literals), что такое замыкание:
> Function literals are closures: they may refer to variables defined in a surrounding function. 
> Those variables are then shared between the surrounding function and the function literal, 
> and they survive as long as they are accessible.

Т.е., переменные действительно **делятся** между внутренней функцией (в нашем случае, анонимной горутиной)
и окружающей её функцией (в нашем случае, функцией main). Для этого, переменные, попадающие в замыкание:
1. Выделяются на куче
2. Передаются через указатель во внутреннюю функцию

В golang версии меньше, чем 1.22, для итерации по циклу создавалась одна переменная, и в ходе цикла менялось её значение,
но адрес оставался тем же, и в замыкание попадал один адрес. В версиях 1.22+, переменные разные и адреса разные.

При выполнении горутины в любой версии golang, она возьмёт значение из замыкания (переданное по указателю) и выведет его в output.

Если версия меньше 1.22, то будет выведено значение, лежащее по одному и тому же адресу. При этом, значения всё равно могут быть разными,
потому что значение меняется во время цикла.

Если версия 1.22 или выше, то адреса в любом случае будут разные, поэтому горутины выведут разные значения.

## Для каких задач используют golang

> В каких сферах IT у Go гегемония, где его преимущественно используют?

golang отличается от других ЯП тем, как он работает с многозадачностью. Другие ЯП используют для этого только 
треды ОС, которые работают по принципе вытесняющей многозадачности. Это значит, что каждый поток получает 
свою порцию процессорного времени, после чего происходит переключение контекста, и процессорное время получает новый поток.

golang использует кооперативную многозадачность, в дополнение к вытесняющей. Эта оптимизация позволяет выполнить
код нескольких горутин в пределах одного потока ОС в то время, пока ОС не переключила контекст. Но переключение
горутин внутри потока не происходит само по себе; один из тригеров для этого -- горутина должна перейти в 
заблокированное состояние, например, при ожидании блокирующего i/o.

Таким образом, golang имеет преимущество, когда в приложении часто происходит блокирующий ввод/вывод. Его можно
использовать для задач быстрой обработки http-запросов (REST, grpc). Запросы к БД также относятся к блокирующему вводу/выводу.

## Third-party библиотеки и boilerplate

> Насколько много библиотек в го, расширяющих базовую функциональность, часто ли приходится писать бойлерплейт код?

> Хотелось бы узнать какими библиотеками принято пользоваться в продакшене, если например нет нужной структуры данных, 
> есть перечень библиотек которым прям все доверяют однозначно? 
> Просто иногда залетают рекомендации на семинарах и лекциях, но непонятно, 
> это личная рекомендация или отраслевой стандарт?

Сам по себе golang -- достаточно низкоуровневый язык. В язык встроены стандартные структуры данных, вроде слайсов и мапов.

Стандартная библиотека в golang выглядит примерно так же -- есть пакеты с основным функциями, которые ожидаются от
типичных языков программирования: работа с датой/временем, с сетью, с вводом/выводом, с ОС и пр.

Повседневная работа часто сводится к разработке множества приложений, которые выполняют сходные функции, например,
grpc-сервисы, или консьюмеры задач из очереди сообщений. Поэтому **да, для типичных приложений действительно
приходится часто писать boilerplate-код**.

Такие задачи возникают повсеместно, и естественно, что есть большое количество решений с открытым исходным кодом, 
которые решают те или иные задачи. Обычно при выборе конкретной библиотеки руководствуются такими соображениями:

1. Насколько решение удобно использовать и насколько качественный у него код.
2. Насколько решение стабильно (мало багов), и то, как оно разрабатывается и поддерживается (как мейнтейнеры реализуют запросы и фиксят баги).
3. Насколько широко используется решение (косвенный индикатор -- количество лайков, количество скачиваний).

Важно понимать, что единых отраслевых стандартов не существует, а решениями пользуются, потому что ими удобно пользоваться.

Преподаватели стараются не предлагать вам откровенно плохие решения, и вы вполне можете использовать рекомендованные 
вам на занятиях библиотеки. Как минимум, это полезно с точки зрения получения опыта. И конечно же, вам никто не запрещает
выбирать другие решения; а если вы выберете плохое решение, то вам на это укажут, и объяснят почему оно плохое.
Это тоже полезно с точки зрения опыта.

## Уязвимости

> Насколько много уязвимостей в Go, какие самые популярные и опасные?

Во-первых, важно понимать, что проблема уязвимостей значительно шире, чем просто кодовая база. Самый простой пример --
SQL-инъекции: наверное, на любом ЯП можно написать код, который собирает SQL-запрос из кусков строк, добавляя
туда неэкранированный ввод пользователя. 

Уязвимости могут быть и на стороне клиента (e.g., CSRF/XSRF, CROS), и во многих других участках инфраструктуры. 

Во-вторых, есть инструменты, которые позволяют автоматизировать поиск уязвимостей в кодовой базе. Рекомендуется
почитать статью на хабре, где проводится обзор таких инструментов: https://habr.com/ru/companies/avito/articles/739144/
