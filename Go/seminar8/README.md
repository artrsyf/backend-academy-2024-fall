# Паттерны проектирования в Go

- [Паттерны проектирования в Go](#паттерны-проектирования-в-go)
  - [Singletone — `sync.Once`](#singletone--synconce)
    - [Преимущества](#преимущества)
    - [Недостатки](#недостатки)
  - [Builder](#builder)
    - [Преимущества](#преимущества-1)
    - [Недостатки](#недостатки-1)
  - [Constructor Func (`New...`)](#constructor-func-new)
    - [Преимущества](#преимущества-2)
    - [Недостатки](#недостатки-2)
  - [Standard Project Layout](#standard-project-layout)
    - [Пример структуры проекта](#пример-структуры-проекта)
    - [Преимущества](#преимущества-3)
    - [Минусы, указанные в Issue к репозиторию](#минусы-указанные-в-issue-к-репозиторию)
  - [CQRS (Command Query Responsibility Segregation)](#cqrs-command-query-responsibility-segregation)
    - [Основные принципы CQRS:](#основные-принципы-cqrs)
    - [Пример](#пример)
    - [Преимущества](#преимущества-4)
    - [Недостатки](#недостатки-3)
  - [Чистая архитектура (Clean Architecture)](#чистая-архитектура-clean-architecture)
    - [Основные принципы Чистой архитектуры](#основные-принципы-чистой-архитектуры)
    - [Пример структуры проекта с чистой архитектурой](#пример-структуры-проекта-с-чистой-архитектурой)
      - [Пример реализации](#пример-реализации)
    - [Преимущества](#преимущества-5)
    - [Недостатки](#недостатки-4)
  - [Domain-Driven Design (DDD)](#domain-driven-design-ddd)
    - [Основные принципы DDD](#основные-принципы-ddd)
    - [Основные концепции DDD](#основные-концепции-ddd)
      - [1. **Модели (Domain Models)**](#1-модели-domain-models)
      - [Пример](#пример-1)
      - [2. **Агрегации (Aggregates)**](#2-агрегации-aggregates)
      - [3. **Объекты-значения (Value Objects)**](#3-объекты-значения-value-objects)
      - [4. **Event Storming**](#4-event-storming)
    - [Основные этапы Event Storming](#основные-этапы-event-storming)
    - [Пример DDD с использованием моделей, агрегаций и объектов-значений](#пример-ddd-с-использованием-моделей-агрегаций-и-объектов-значений)


---

## Singletone — `sync.Once`

**Singletone** — это паттерн, который гарантирует, что экземпляр класса будет создан только один раз.

В Go для реализации Singletone часто используют `sync.Once`, который обеспечивает потокобезопасное выполнение функции один раз.

```go
package main

import (
    "fmt"
    "sync"
)

type Singleton struct {
    Name string
}

var instance *Singleton
var once sync.Once

func GetInstance() *Singleton {
    once.Do(func() {
        instance = &Singleton{Name: "MySingleton"}
    })
    return instance
}

func main() {
    s1 := GetInstance()
    s2 := GetInstance()

    fmt.Println(s1 == s2)  // true, так как это один и тот же экземпляр
}
```

### Преимущества

- Потокобезопасность без необходимости использования явных блокировок.
- Ленивая инициализация объекта.

### Недостатки

- При избыточном использовании Singletone может снизиться тестируемость и расширяемость системы.

---

## Builder

**Builder** — это паттерн, который помогает поэтапно создавать сложные объекты.

Пример:

```go
package main

import "fmt"

type Car struct {
    Brand string
    Color string
    Speed int
}

type CarBuilder struct {
    car Car
}

func NewCarBuilder() *CarBuilder {
    return &CarBuilder{}
}

func (b *CarBuilder) SetBrand(brand string) *CarBuilder {
    b.car.Brand = brand
    return b
}

func (b *CarBuilder) SetColor(color string) *CarBuilder {
    b.car.Color = color
    return b
}

func (b *CarBuilder) SetSpeed(speed int) *CarBuilder {
    b.car.Speed = speed
    return b
}

func (b *CarBuilder) Build() Car {
    return b.car
}

func main() {
    car := NewCarBuilder().
        SetBrand("Tesla").
        SetColor("Red").
        SetSpeed(250).
        Build()

    fmt.Println(car)
}
```

### Преимущества

- Удобно для создания объектов с большим количеством параметров.
- Позволяет избежать конструкторов с множеством аргументов.

### Недостатки

- Может быть избыточным для простых объектов.

---

## Constructor Func (`New...`)

В Go конструкторы не являются встроенным механизмом, как в других языках. Вместо этого для создания и инициализации объектов принято использовать функцию, которая начинается с префикса `New...`.

Пример:

```go
package main

import "fmt"

type Person struct {
    Name string
    Age  int
}

func NewPerson(name string, age int) *Person {
    return &Person{Name: name, Age: age}
}

func main() {
    p := NewPerson("Alice", 30)
    fmt.Println(p)
}
```

### Преимущества

- Явное создание и инициализация объектов.
- Контроль за процессом создания объекта.

### Недостатки

- Функции могут перегружаться при большом количестве параметров, что снижает читаемость.

---

## Standard Project Layout

Standard Project Layout — это общепринятая структура для Go-проектов. Она описана в репозитории [golang-standards/project-layout](https://github.com/golang-standards/project-layout).

### Пример структуры проекта

```
├── cmd           # точка входа для приложений
├── internal      # приватные пакеты, доступные только внутри проекта
├── pkg           # общие библиотеки, которые могут использоваться в других проектах
├── api           # API-спецификации
├── web           # файлы для фронтенда
├── scripts       # скрипты для автоматизации
├── docs          # документация проекта
```

### Преимущества

- Четкое разделение ответственности.
- Возможность масштабирования проекта.
- Общепринятый стандарт, что упрощает работу в команде.


### Минусы, указанные в Issue к репозиторию

  - Некоторые считают эту структуру слишком сложной для небольших проектов.
  - Стандартная структура может быть избыточной для приложений, которые не предполагают значительного роста.
  - Часто нет необходимости использовать все предложенные директории.

---


## CQRS (Command Query Responsibility Segregation)

**CQRS** — это паттерн, который разделяет операции чтения (Queries) и изменения состояния (Commands) системы. Основная идея заключается в том, что запросы (чтение данных) и команды (изменение данных) обрабатываются по-разному, что позволяет оптимизировать обе операции независимо.

### Основные принципы CQRS:

1. **Разделение чтения и записи**:
   - Чтение и запись данных могут быть организованы через разные модели данных. Например, данные для команд могут иметь более сложную структуру, а для чтения могут быть оптимизированы для быстрого доступа.

2. **Модели данных**:
   - **Команды**: отвечают за изменение состояния системы. В командах используются модели, которые соответствуют бизнес-логике.
   - **Запросы**: предоставляют данные в виде, который удобен для чтения, часто оптимизируются для быстрого извлечения данных.

3. **Отсутствие сильной консистентности**:
   - В CQRS часто используется **Eventual Consistency** — модели для чтения могут быть обновлены асинхронно после выполнения команды.

### Пример

```go
// Команда
type CreateUserCommand struct {
    Name string
    Age  int
}

// Запрос
type GetUserQuery struct {
    ID int
}
```

### Преимущества

- Улучшение производительности чтения и записи за счет независимой оптимизации.
- Упрощение масштабирования, так как чтение и запись можно масштабировать по-разному.
- Повышение безопасности — команды могут быть более строго контролируемыми.

### Недостатки

- Увеличение сложности проекта из-за необходимости поддерживать две разные модели данных.
- Требует тщательной обработки транзакций и консистентности данных.

---

## Чистая архитектура (Clean Architecture)

**Чистая архитектура** — это архитектурный подход, предложенный Робертом Мартином (дядя Боб), который фокусируется на том, чтобы отделить бизнес-логику от технических деталей (например, базы данных, пользовательских интерфейсов, фреймворков). Основной целью является создание модульной, легко поддерживаемой и тестируемой системы.

### Основные принципы Чистой архитектуры

1. **Зависимости направлены внутрь**:
   - Модули на более низком уровне (например, бизнес-логика) не должны зависеть от внешних деталей (интерфейсов, баз данных и т. д.). Все зависимости направлены внутрь, в сторону бизнес-логики.

2. **Разделение на уровни**:
   - **Entities (сущности)**: содержат основные бизнес-правила.
   - **Use Cases (сценарии использования)**: описывают действия, которые можно совершить над сущностями. Например, обработка команд и запросов.
   - **Interface Adapters (адаптеры интерфейса)**: преобразуют данные между внешними системами (например, базой данных или пользовательским интерфейсом) и бизнес-логикой.
   - **Frameworks & Drivers (фреймворки и драйверы)**: внешний слой, где расположены детали, такие как базы данных, HTTP-фреймворки и другие инфраструктурные компоненты.

3. **Инверсия зависимости**:
   - Модули более высокого уровня не должны зависеть от низкоуровневых компонентов (например, репозиториев). Вместо этого они зависят от абстракций (интерфейсов), что обеспечивает гибкость и заменяемость компонентов.

### Пример структуры проекта с чистой архитектурой

```
├── entities            # Основные бизнес-сущности
├── usecases            # Логика и сценарии использования
├── interfaces          # Адаптеры для базы данных, внешних API и пользовательского интерфейса
├── infrastructure      # Реализация хранилищ данных, драйверов и API
```

#### Пример реализации

```go
// entities/user.go
package entities

type User struct {
    ID   int
    Name string
}

// usecases/user_service.go
package usecases

import "myapp/entities"

type UserRepository interface {
    GetByID(id int) (*entities.User, error)
}

type UserService struct {
    repo UserRepository
}

func NewUserService(repo UserRepository) *UserService {
    return &UserService{repo: repo}
}

func (s *UserService) GetUser(id int) (*entities.User, error) {
    return s.repo.GetByID(id)
}
```

### Преимущества

- **Тестируемость**: поскольку бизнес-логика отделена от инфраструктуры, ее легко тестировать в изоляции.
- **Модульность**: каждая часть системы изолирована, что упрощает ее модификацию и замену.
- **Гибкость**: детали (например, базы данных) можно легко заменить без изменения бизнес-логики.

### Недостатки

- **Сложность**: для небольших проектов чистая архитектура может быть избыточной.
- **Нагрузки на разработчиков**: требует понимания и правильного применения принципов разделения ответственности и инверсии зависимостей.


## Domain-Driven Design (DDD)

**Domain-Driven Design (DDD)** — это подход к проектированию программного обеспечения, основанный на создании модели предметной области и ее тесной интеграции с бизнес-логикой. В центре внимания DDD находится понимание и описание доменной области через призму бизнеса. Основные элементы DDD помогают разделить систему на части, отражающие реальный бизнес и правила, что упрощает разработку, поддержание и масштабирование кода.

### Основные принципы DDD

1. **Моделирование домена**: фокус на том, как предметная область и ее сущности описываются в терминах бизнеса.
2. **Общая терминология (Ubiquitous Language)**: терминология, понятная как разработчикам, так и бизнесу, используется в коде и в обсуждениях, чтобы устранить разрывы в коммуникации.
3. **Четкое разделение доменной логики и технической инфраструктуры**.

---

### Основные концепции DDD

#### 1. **Модели (Domain Models)**

Модель — это абстракция реальной бизнес-логики, которая отражает ключевые аспекты предметной области. Она позволяет описывать, как сущности взаимодействуют между собой и с внешней средой. Модели — это основной способ представления и проектирования бизнес-логики в DDD.

#### Пример

```go
// Пример модели пользователя в Go
package domain

type User struct {
    ID   int
    Name string
    Age  int
}
```

Модели могут представлять сущности, агрегации, объекты-значения и другие элементы, описывающие доменную логику.

---

#### 2. **Агрегации (Aggregates)**

**Агрегация** — это коллекция взаимосвязанных объектов, которые рассматриваются как одно целое. Агрегация определяет границы транзакций, консистентности и инкапсуляции данных.

Каждая агрегация имеет **агрегатный корень (Aggregate Root)** — это основной объект, через который осуществляется доступ к другим объектам в агрегации.

Пример агрегации — заказ и связанные с ним товары:

```go
type Order struct {
    ID       int
    Products []Product // Агрегация товаров
}

type Product struct {
    ID    int
    Name  string
    Price float64
}

// Создание нового заказа через корневую сущность агрегации
func NewOrder() *Order {
    return &Order{}
}

func (o *Order) AddProduct(product Product) {
    o.Products = append(o.Products, product)
}
```

**Принципы агрегации**:

- **Границы консистентности**: все изменения внутри агрегации должны происходить атомарно. Если нужно изменить несколько объектов внутри агрегации, это делается через агрегатный корень.
- **Целостность данных**: агрегатный корень отвечает за целостность данных в агрегации.

---

#### 3. **Объекты-значения (Value Objects)**

**Value Object (объект-значение)** — это объект, который определяется не своим уникальным идентификатором, а своими атрибутами. В отличие от сущностей, объекты-значения не имеют состояния и могут быть взаимозаменяемыми.

Например, объект-значение может представлять деньги или адрес:

```go
type TCourseID int64 // VO
type TCourseName string // VO

type Course struct { // Aggregate
    ID   TCourseID
    Name TCourseName
}
```

**Принципы объектов-значений**:

- Они должны быть **иммутабельны**. Это значит, что после создания объект-значение не может изменяться.
- Логика их сравнения основана на значениях полей, а не на идентификационном признаке.

---

#### 4. **Event Storming**

**Event Storming** — это методология визуального моделирования событий и процессов, используемая для понимания бизнес-логики и проектирования системы на основе DDD. Этот подход помогает разработчикам и бизнесу совместно создавать модели событий, которые происходят в предметной области.

### Основные этапы Event Storming

1. **Обнаружение доменных событий**:
   - Определение ключевых событий, происходящих в бизнесе. Эти события обычно формулируются в прошедшем времени, например: "Заказ был создан", "Оплата прошла успешно".

2. **Определение команд**:
   - Команды — это действия, инициирующие события. Например: "Создать заказ", "Подтвердить оплату".

3. **Определение агрегаций и участников**:
   - Определяются агрегации и объекты, которые участвуют в процессе обработки команд и событий.

4. **Проектирование реакций на события**:
   - Важной частью процесса является понимание, как система реагирует на события, какие действия они инициируют.

**Преимущества Event Storming**:

- Быстрое и интерактивное понимание ключевых процессов и событий в бизнесе.
- Вовлечение всех участников (и бизнес-аналитиков, и разработчиков) в процесс проектирования.
- Возможность увидеть картину всей системы, выявить скрытые зависимости и проблемы.

---

### Пример DDD с использованием моделей, агрегаций и объектов-значений

Допустим, мы проектируем систему заказа товаров в интернет-магазине.

1. **Модели**
   - Основные сущности — это **заказ**, **товар**, **пользователь**.
2. **Агрегация**
   - Агрегация может включать заказ и связанные товары.
3. **Объекты-значения**
   - Объект-значение может представлять **цену товара** или **адрес доставки**.

Пример кода:

```go
// Объект-значение "Цены"
type Price struct {
    Amount   float64
    Currency string
}

// Сущность "Товар"
type Product struct {
    ID    int
    Name  string
    Price Price
}

// Агрегация "Заказ"
type Order struct {
    ID       int
    Products []Product
    Total    Price
}

// Добавление товара в заказ
func (o *Order) AddProduct(product Product) {
    o.Products = append(o.Products, product)
    o.calculateTotal()
}

// Рассчитать общую стоимость заказа
func (o *Order) calculateTotal() {
    total := 0.0
    for _, product := range o.Products {
        total += product.Price.Amount
    }
    o.Total = Price{Amount: total, Currency: "USD"}
}
```
