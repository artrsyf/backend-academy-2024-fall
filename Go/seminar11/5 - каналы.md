- [Каналы](#каналы)
  - [Устройство](#устройство)
  - [Операции с буфером](#операции-с-буфером)
  - [Ожидание чтения](#ожидание-чтения)
  - [Ожидание записи](#ожидание-записи)

# Каналы

## Устройство

Структура канала из исходных кодов [рантайма golang 1.23](https://github.com/golang/go/blob/release-branch.go1.23/src/runtime/chan.go):
```go
type hchan struct {
    qcount   uint           // total data in the queue
    dataqsiz uint           // size of the circular queue
    buf      unsafe.Pointer // points to an array of dataqsiz elements
    elemsize uint16
    closed   uint32
    elemtype *_type // element type
    sendx    uint   // send index
    recvx    uint   // receive index
    recvq    waitq  // list of recv waiters
    sendq    waitq  // list of send waiters

    // lock protects all fields in hchan, as well as several
    // fields in sudogs blocked on this channel.
    //
    // Do not change another G's status while holding this lock
    // (in particular, do not ready a G), as this can deadlock
    // with stack shrinking.
    lock mutex
}
```

Как видно, канал не нуждается в защите мьютексом, потому что уже содержит мьютекс. 
Почти все операции с каналом (запись и чтение) включают в себя использование мьютекса,
кроме отдельных исключений, сделанных для оптимизации.

Канал занимает большой (относительно других стандартных типов) объём памяти, поэтому 
каналы всегда передаются по указателю. Другими словами, значением переменной типа канал 
является указатель на структуру `hchan`.

## Операции с буфером

Если горутина записывает значение в канал с буфером, **и при этом буфер не заполнен**,
то записываемое **значение копируется** в буфер канала.

Аналогично, если горутина читает данные из канала с буфером, **и при этом буфер не пуст**,
то читаемое **значение копируется** из буфера канала в горутину.

Операции с буфером защищены мьютексом, поэтому при использовании канала с буфером, горутины
всё равно могут переходить в состояние `waiting`. 

Однако каналы обычно не являются причиной потерь производительности, из-за того, 
что конкуренция происходит только при операциях с каналом; а каждая горутина 
получает свою копию разделяемых данных.

## Ожидание чтения

Ожидание чтения происходит, когда горутина пытается читать из канала, буфер которого пуст.
Это может происходить по двум почти одинаковым причинам:

- у канала есть буфер, и он пустой
- у канала нет буфера, и никакая другая горутина не ожидает записи в этот канал

В этом случае, горутина, которая пытается прочитать из канала, переходит в состояние `waiting`.
В очередь получателей канала (поле `recvq`, представляет собой связный список) добавляются специальные
данные, которые содержат в себе указатель на ожидающую горутину и область памяти для будущей
записи значения:

```go
type sudog struct {
    // The following fields are protected by the hchan.lock of the
    // channel this sudog is blocking on. shrinkstack depends on
    // this for sudogs involved in channel ops.

    g *g
    elem unsafe.Pointer // data element (may point to stack)
	
    ...
}
```

Ожидается, что дальше какая-то горутина запишет данные в этот канал (или закроет его).
При попытке записи, если очередь получателей канала `recvq` не пуста, то из неё будет
извлечено значение типа `sudog`, которые содержит данные о ждущей горутине.

Разделяемые данные будут записаны не в буфер канала (даже если он есть и не пуст), 
а напрямую в стек читающей горутины (поле `elem`). В результате этого, горутина,
которая ожидала чтения, перейдёт в состояние `runnable`.

## Ожидание записи

Ожидание записи происходит, когда горутина пытается записать в канал, буфер которого заполнен.
Это тоже может происходить по двум почти одинаковым причинам:

- у канала есть буфер, и он заполнен
- у канала нет буфера, и никакая другая горутина не ожидает чтения из этого канала

В этом случае, горутина, которая пытается записать в канал, переходит в состояние `waiting`.
В очередь отправителей канала (поле `sendq`, тоже связный список) добавляется значение типа `sudog`.
Оно содержит указатель на ожидающую горутину и область памяти, содержащую значение, 
которое ожидает записи в канал.

Ожидается, что дальше какая-то горутина прочитает данные из этого канала. 
При попытке чтения, если очередь отправителей канала `sendq` не пуста, то из неё
будет извлечено значение типа `sudog`, которые содержит данные о ждущей горутине.

Значение из области памяти, на которую указывает `elem`, будет скопировано
либо в освободившийся буфер канала, либо напрямую в стек горутины, ожидающей чтения.

