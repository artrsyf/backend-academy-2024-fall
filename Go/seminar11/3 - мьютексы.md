- [Мьютексы](#мьютексы)
  - [sync.Mutex](#syncmutex)
    - [Пример использования sync.Mutex](#пример-использования-syncmutex)
    - [Состояние гонки](#состояние-гонки)
  - [sync.RWMutex](#syncrwmutex)

# Мьютексы

Мьютекс (mutex - mutual exclusive) -- примитив синхронизации, который позволяет отдельным горутинам 
получать **исключительный** доступ к разделяемым данным.

Для этого несколько горутин обращаются к одной и той же переменной-мьютексу; важно, чтобы горутины
обращались к одной и той же области памяти, а не к разным копиям одного мьютекса. Поэтому, если 
возникает необходимость передать куда-то мьютекс (как отдельной переменной, так и в составе структуры),
то передавать нужно всегда по указателю, а не по значению.

## sync.Mutex

Простой мьютекс с одним типом блокировки. Когда горутина вызывает для мьютекса `Lock()`, она переходит
в состояние `waiting`. Чтобы эффективнее использовать поток ОС (M), планировщик может отдать M другой горутине.

Когда горутине удастся получить блокировку, то она перейдёт в состояние `runnable`, и планировщик сможет передать
ей M, чтобы горутина продолжила выполнять код. Пока горутина не снимет блокировку (вызвав для мьютекса `Unlock()`),
все остальные горутины, которые вызвали `Lock()` для этого же мьютекса, будут оставаться в состоянии `waiting`.

Рекомендуется планировать парный вызов `Unlock()` с помощью `defer`.

### Пример использования sync.Mutex

Допустим, нужно определить, сколько чисел в данном слайсе соответствуют данному предикату. 
[Код](./examples/part3/mutex).

В этом примере, `WorkerPoolCounter` реализует параллельный подсчёт данных. Результат 
бенчмарка, который сравнивает параллельный и последовательный способы вычисления:

```
BenchmarkSeqCounter
BenchmarkSeqCounter-12           	     490	   2473798 ns/op
BenchmarkWorkerPoolCounter
BenchmarkWorkerPoolCounter-12    	    1975	    609716 ns/op
PASS
```

Видно, что параллельное выполнение выполняется примерно в 4 раза быстрее.

### Состояние гонки

В примере выше, горутины относительно редко конкурировали за мьютекс 
(предикат выполнялся в среднем для 1 числа из 2 000). Посмотрим, что будет,
если горутины будут конкурировать за мьютекс чаще (в 10 раз чаще):

```
BenchmarkSeqCounter
BenchmarkSeqCounter-12           	     481	   2456490 ns/op
BenchmarkWorkerPoolCounter
BenchmarkWorkerPoolCounter-12    	     619	   1963926 ns/op
PASS
```

Параллельный код по-прежнему выполняется быстрее последовательного,
но уже ненамного.

Если горутины будут конкурировать за мьютекс ещё чаще (в 100 раз чаще, чем сначала):

```
BenchmarkSeqCounter
BenchmarkSeqCounter-12                       	     482	   2400687 ns/op
BenchmarkWorkerPoolCounter
BenchmarkWorkerPoolCounter-12                	      79	  14219775 ns/op
PASS
```

Видно, что параллельное выполнение стало выполняться медленнее, чем последовательное.

Мьютекс выполняет задачу синхронизации данных, но при этом, он может являться узким местом;
это обязательно нужно учитывать при написании кода.

Более оптимальным подходом здесь будет вообще не использовать мьютекс, позволив
каждой горутине работать с полностью изолированными от остальных данными. 
Если реализовать бенчмарк для такого подхода, то можно увидеть, что параллельное
выполнение происходит устойчиво быстрее последовательного, независимо от данных:

```
# NumberCheckerV1
BenchmarkSeqCounter
BenchmarkSeqCounter-12                       	     460	   2451147 ns/op
BenchmarkWorkerPoolCounter
BenchmarkWorkerPoolCounter-12                	    1965	    570239 ns/op
BenchmarkWorkerPoolWithoutMutexCounter
BenchmarkWorkerPoolWithoutMutexCounter-12    	    2193	    538581 ns/op
PASS

# NumberCheckerV2
BenchmarkSeqCounter
BenchmarkSeqCounter-12                       	     474	   2468608 ns/op
BenchmarkWorkerPoolCounter
BenchmarkWorkerPoolCounter-12                	     668	   1842058 ns/op
BenchmarkWorkerPoolWithoutMutexCounter
BenchmarkWorkerPoolWithoutMutexCounter-12    	    1774	    680295 ns/op
PASS

# NumberCheckerV3
BenchmarkSeqCounter
BenchmarkSeqCounter-12                       	     487	   2397327 ns/op
BenchmarkWorkerPoolCounter
BenchmarkWorkerPoolCounter-12                	     100	  13837132 ns/op
BenchmarkWorkerPoolWithoutMutexCounter
BenchmarkWorkerPoolWithoutMutexCounter-12    	    1574	    744220 ns/op
PASS
```

## sync.RWMutex

`sync.RWMutex` является более специализированной версией `sync.Mutex`, 
если требуется обеспечить защиту данных для [читателей и писателей](https://ru.wikipedia.org/wiki/%D0%97%D0%B0%D0%B4%D0%B0%D1%87%D0%B0_%D0%BE_%D1%87%D0%B8%D1%82%D0%B0%D1%82%D0%B5%D0%BB%D1%8F%D1%85-%D0%BF%D0%B8%D1%81%D0%B0%D1%82%D0%B5%D0%BB%D1%8F%D1%85).

Помимо пары функций `Lock()` / `Unlock()`, есть ещё пара `RLock()` / `RUnlock()`. Предлагается
использовать первую пару для блокировки писателя (на запись), а вторую пару для блокировки читателя (на чтение).

Читатели могут получать доступ к данным, не дожидаясь остальных читателей. Если доступ к данным
хочет получить писатель, то он:

1. Захватывает встроенный `sync.Mutex` (происходит конкуренция с другими писателями).
2. После этого, дожидается, когда все читатели, которые к этому времени начали работу с данными, завершили её. 
3. Все новые читатели и остальные писатели будут ждать, пока писатель не закончит работу с данными (`Unlock`).

[Пример кода](./examples/part3/rwmutex). Это кусок реального компонента `agent-gateway`, который выполняет
функцию in-memory кэша данных API. Этот компонент обслуживает grpc-запросы с агентов, расположенных на тысячах
нодах кластеров.

Ещё более оптимальным (но и более сложным) было бы использовать `sync.Map`, но в настоящий момент
нас устраивает производительность комбинации map + `sync.RWMutex`: p99 времени обработки запроса
со стороны агента не превышает 10мс, приложение обслуживает запросы с тысяч нод и потребляет 
примерно 0.3CPU и 3GB RAM (умноженные на 2 экземпляра приложения).
